//! UI metadata renderer for component inspector
//!
//! This module provides functionality to render component UI based on metadata
//! generated by the EditorUI derive macro.

use engine::component_system::field_access::{FieldAccess, FieldValue};
use engine::component_system::ui_metadata::{ComponentUIMetadata, UIFieldMetadata, UIWidgetType};
use engine::prelude::{Quat, Vec3};
use imgui::{Drag, Ui};
use tracing::debug;

/// Render a component's UI based on its metadata
///
/// Returns true if any field was modified
pub fn render_component_ui<T>(
    ui: &Ui,
    component: &mut T,
    metadata: &ComponentUIMetadata,
    _entity: hecs::Entity,
) -> bool
where
    T: FieldAccess + ?Sized,
{
    let mut modified = false;

    debug!(
        field_count = metadata.fields.len(),
        "Rendering component UI from metadata"
    );

    for field in &metadata.fields {
        if field.hidden {
            continue;
        }

        debug!(
            field_name = &field.name,
            widget_type = ?field.widget,
            "Rendering field"
        );

        modified |= render_field_ui(ui, component, field);
    }

    modified
}

/// Render a single field's UI based on its metadata
fn render_field_ui<T>(ui: &Ui, component: &mut T, field: &UIFieldMetadata) -> bool
where
    T: FieldAccess + ?Sized,
{
    let mut modified = false;

    // Get the current value
    let current_value = component.get_field(&field.name);
    if current_value.is_none() {
        return false;
    }
    let current_value = current_value.unwrap();

    // Display label if provided
    if let Some(label) = &field.label {
        ui.text(format!("{label}:"));
    }

    // Add tooltip if provided
    if let Some(tooltip) = &field.tooltip {
        if ui.is_item_hovered() {
            ui.tooltip_text(tooltip);
        }
    }

    // Render widget based on type
    match &field.widget {
        UIWidgetType::DragFloat {
            min,
            max,
            speed,
            format,
        } => {
            if let Some(mut value) = current_value.as_f32() {
                ui.set_next_item_width(100.0);
                if !field.readonly
                    && Drag::new(format!("##{}", field.name))
                        .range(*min, *max)
                        .speed(*speed)
                        .display_format(format)
                        .build(ui, &mut value)
                {
                    component.set_field(&field.name, FieldValue::Float(value));
                    modified = true;
                } else if field.readonly {
                    ui.text(format!("{value:.3}"));
                }
            }
        }
        UIWidgetType::DragInt {
            min,
            max,
            speed,
            format,
        } => {
            if let Some(mut value) = current_value.as_i32() {
                ui.set_next_item_width(100.0);
                if !field.readonly
                    && Drag::new(format!("##{}", field.name))
                        .range(*min, *max)
                        .speed(*speed)
                        .display_format(format)
                        .build(ui, &mut value)
                {
                    component.set_field(&field.name, FieldValue::Int(value));
                    modified = true;
                } else if field.readonly {
                    ui.text(format!("{value}"));
                }
            }
        }
        UIWidgetType::InputText {
            multiline,
            max_length: _,
        } => {
            if let Some(current_str) = current_value.as_string() {
                let mut buffer = current_str.clone();
                if !field.readonly {
                    if *multiline {
                        let lines = field
                            .properties
                            .get("lines")
                            .and_then(|v| v.as_str())
                            .and_then(|s| s.parse::<f32>().ok())
                            .unwrap_or(3.0);
                        let size = [0.0, ui.text_line_height_with_spacing() * lines];
                        if ui
                            .input_text_multiline(format!("##{}", field.name), &mut buffer, size)
                            .build()
                        {
                            component.set_field(&field.name, FieldValue::String(buffer));
                            modified = true;
                        }
                    } else {
                        if ui
                            .input_text(format!("##{}", field.name), &mut buffer)
                            .build()
                        {
                            component.set_field(&field.name, FieldValue::String(buffer));
                            modified = true;
                        }
                    }
                } else {
                    ui.text(&buffer);
                }
            }
        }
        UIWidgetType::Checkbox => {
            if let Some(mut value) = current_value.as_bool() {
                if !field.readonly && ui.checkbox(format!("##{}", field.name), &mut value) {
                    component.set_field(&field.name, FieldValue::Bool(value));
                    modified = true;
                } else if field.readonly {
                    ui.text(if value { "Yes" } else { "No" });
                }
            }
        }
        UIWidgetType::ColorEdit { alpha } => {
            if *alpha {
                if let Some(mut color) = current_value.as_color_rgba() {
                    if !field.readonly && ui.color_edit4(format!("##{}", field.name), &mut color) {
                        component.set_field(&field.name, FieldValue::ColorRGBA(color));
                        modified = true;
                    } else if field.readonly {
                        ui.text(format!(
                            "RGBA({:.2}, {:.2}, {:.2}, {:.2})",
                            color[0], color[1], color[2], color[3]
                        ));
                    }
                }
            } else {
                if let Some(mut color) = current_value.as_color_rgb() {
                    if !field.readonly && ui.color_edit3(format!("##{}", field.name), &mut color) {
                        component.set_field(&field.name, FieldValue::ColorRGB(color));
                        modified = true;
                    } else if field.readonly {
                        ui.text(format!(
                            "RGB({:.2}, {:.2}, {:.2})",
                            color[0], color[1], color[2]
                        ));
                    }
                }
            }
        }
        UIWidgetType::Vec3Input { speed, format } => {
            if let Some(vec3) = current_value.as_vec3() {
                modified |= render_vec3_input(
                    ui,
                    &field.name,
                    vec3,
                    *speed,
                    format,
                    field.readonly,
                    component,
                );
            }
        }
        UIWidgetType::QuatInput { speed, format } => {
            if let Some(quat) = current_value.as_quat() {
                modified |= render_quat_input(
                    ui,
                    &field.name,
                    quat,
                    *speed,
                    format,
                    field.readonly,
                    component,
                );
            }
        }
        UIWidgetType::Custom { function } => {
            ui.text(format!("Custom UI: {function}"));
        }
    }

    modified
}

/// Render a Vec3 input widget
fn render_vec3_input<T>(
    ui: &Ui,
    field_name: &str,
    current: Vec3,
    speed: f32,
    format: &str,
    readonly: bool,
    component: &mut T,
) -> bool
where
    T: FieldAccess + ?Sized,
{
    let mut modified = false;
    let mut x = current.x;
    let mut y = current.y;
    let mut z = current.z;

    // Calculate column layout
    let available_width = ui.content_region_avail()[0];
    let label_width = 20.0;
    let spacing = unsafe { ui.style().item_spacing[0] };
    let input_width = (available_width - label_width * 3.0 - spacing * 4.0) / 3.0;

    ui.text("X:");
    ui.same_line();
    ui.set_next_item_width(input_width);
    if !readonly
        && Drag::new(format!("##{}x", field_name))
            .speed(speed)
            .display_format(format)
            .build(ui, &mut x)
    {
        modified = true;
    } else if readonly {
        ui.text(format!("{x:.3}"));
        ui.same_line();
    }

    ui.same_line();
    ui.text("Y:");
    ui.same_line();
    ui.set_next_item_width(input_width);
    if !readonly
        && Drag::new(format!("##{}y", field_name))
            .speed(speed)
            .display_format(format)
            .build(ui, &mut y)
    {
        modified = true;
    } else if readonly {
        ui.text(format!("{y:.3}"));
        ui.same_line();
    }

    ui.same_line();
    ui.text("Z:");
    ui.same_line();
    ui.set_next_item_width(input_width);
    if !readonly
        && Drag::new(format!("##{}z", field_name))
            .speed(speed)
            .display_format(format)
            .build(ui, &mut z)
    {
        modified = true;
    } else if readonly {
        ui.text(format!("{z:.3}"));
    }

    if modified {
        component.set_field(field_name, FieldValue::Vec3(Vec3::new(x, y, z)));
    }

    modified
}

/// Render a Quaternion input widget (as euler angles)
fn render_quat_input<T>(
    ui: &Ui,
    field_name: &str,
    current: Quat,
    speed: f32,
    format: &str,
    readonly: bool,
    component: &mut T,
) -> bool
where
    T: FieldAccess + ?Sized,
{
    let mut modified = false;

    // Convert quaternion to euler angles
    let (mut yaw, mut pitch, mut roll) = current.to_euler(glam::EulerRot::YXZ);
    yaw = yaw.to_degrees();
    pitch = pitch.to_degrees();
    roll = roll.to_degrees();

    // Calculate column layout
    let available_width = ui.content_region_avail()[0];
    let label_width = 40.0;
    let spacing = unsafe { ui.style().item_spacing[0] };
    let input_width = (available_width - label_width * 3.0 - spacing * 4.0) / 3.0;

    ui.text("Pitch:");
    ui.same_line();
    ui.set_next_item_width(input_width);
    if !readonly
        && Drag::new(format!("##{}pitch", field_name))
            .speed(speed)
            .display_format(format)
            .build(ui, &mut pitch)
    {
        modified = true;
    } else if readonly {
        ui.text(format!("{pitch:.1}°"));
        ui.same_line();
    }

    ui.same_line();
    ui.text("Yaw:");
    ui.same_line();
    ui.set_next_item_width(input_width);
    if !readonly
        && Drag::new(format!("##{}yaw", field_name))
            .speed(speed)
            .display_format(format)
            .build(ui, &mut yaw)
    {
        modified = true;
    } else if readonly {
        ui.text(format!("{yaw:.1}°"));
        ui.same_line();
    }

    ui.same_line();
    ui.text("Roll:");
    ui.same_line();
    ui.set_next_item_width(input_width);
    if !readonly
        && Drag::new(format!("##{}roll", field_name))
            .speed(speed)
            .display_format(format)
            .build(ui, &mut roll)
    {
        modified = true;
    } else if readonly {
        ui.text(format!("{roll:.1}°"));
    }

    if modified {
        // Convert back to quaternion
        let quat = Quat::from_euler(
            glam::EulerRot::YXZ,
            yaw.to_radians(),
            pitch.to_radians(),
            roll.to_radians(),
        );
        component.set_field(field_name, FieldValue::Quat(quat));
    }

    modified
}
